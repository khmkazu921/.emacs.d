`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// Company: 
// Engineer: 
// 
// Create Date: 12/14/2020
// Design Name: 
// Module Name: read initial mesh
// Project Name: 
// Target Devices: 
// Tool Versions: 
// Description: 
// 
// Dependencies: 
// 
// Revision:
// Revision 0.01 - File Created
// Additional Comments:
// 
//////////////////////////////////////////////////////////////////////////////////

module read_initial_mesh
  #(
    parameter PORT_NUM = 32,
    parameter URAM_NUM = 16,
    parameter MESH_PER_URAM = 8,
    parameter BURST_LEN  = 16,
    parameter DATA_WIDTH = 256,
    parameter BLOCK_LEN = 40,
    parameter LOG_DATA_DEPTH = 12 //log(40block * 64mesh)
    )
    (
     input clk,
     input resetn,
     input flag_finish_quater,
     input reg [1:0] state,
     AXI3 axi3,
     bram spm
     );

    // Write to URAM
    reg [ 7:0] piramid_id = 0;
    reg [ 9:0] a = 0;
    reg [ 1:0] q;
    reg  is_upper;
    reg  flag_start_calc;
    reg  resetn1;

    // flags
    wire flag_last_quater  = (q >= 3);
    wire flag_last_advance = (a >= 511);
    wire flag_finish_upper = flag_finish_quater &  is_upper[0];
    wire flag_finish_lower = flag_finish_quater & ~is_upper[0];
    wire flag_start_calc   = start_calc;
    
    
    ////////////////////////////////
    // Control quater and Advance //
    ////////////////////////////////

    //                          ________
    // is_upper            ____|        |____
    //                        _
    // flag_finish_quater  __| |_________
    //                                 _
    // flag_finish_upper   ___________| |__
    //
    // 
    
    always_ff @(posedge clk) begin
        resetn1 <= resetn;
        if(~resetn) begin
            a <= 0;
            q <= 0;
            start_calc <= 0;
        end
        else begin
            flag_start_calc <= (resetn & ~resetn1);
            
            if(flag_finish_quater) begin
                is_upper <= ~is_upper;
                q <= q + 1;
            end

            if(flag_last_quater) begin
                q <= 0;
                if(flag_finish_upper) begin
                    a++;
                end
                
                if(flag_last_advance) begin
                    a <= 0;
                    piramid_id++;
                end
            end // if (flag_last_quater)
        end
    end

    //////////////////////////////////////
    // Generate block location via BRAM //
    //////////////////////////////////////

    localparam int param_pointer[8] = {2,3,3,4,4,5,5,6};
    wire [8:0] addr_init_blk = piramid_id; // log2(3072/128*16) = 8.5
    wire [3:0] dout_init_blk; // 64/4
    reg  [3:0] offset[8], init_pointer, wb_pointer[8];
    wire [3:0] init_by;
    reg  [3:0] init_bz;
    reg        ena_init_blk;
    reg        valid_init_blk;
    reg        valid_bybz;

    init_blk init_blk_0
      (
       .clka (clk),
       .addra(addr_init_blk),
       .ena  (ena_init_blk),
       .douta(dout_init_blk)
       );

    reg flag_last_by;
    wire flag_init_blk;
    always_comb begin
        case(spm_state)
            INIT_BLK: begin
                flag_last_bz <= init_bz >= 15;
                flag_last_by <= (is_upper) ?
                                (init_pointer >= param_pointer[8-init_bz]-1) :
                                (init_pointer >= param_pointer[init_bz]-1);
                init_by      <= offset[init_bz] + pointer;
            end
            WRITE_BACK: begin
                flag_last_bz <= init_bz >= 15;
                flag_last_by <= 1;
                wb_by        <= offset[wb_bz];
            end
        endcase
    end

    always_ff @(posedge clk) begin
        if(~resetn) begin
            ena_init_blk <= 0;
            valid_init_blk <= 0;
        end
        // init blk
        else begin
            if( flag_start_calc ) begin
                spm_state  <= INIT_BLK;
            end else if( flag_finish_calc_piramid ) begin
                wb_bz <= 0;
                spm_state  <= WRITE_BACK;
            end

            ena_init_blk <= (flag_last_by & &flag_finish_read_blk) | flag_start_calc;
            
            case (spm_state)
                INIT_BLK: begin
                    if(~|addr_fifo_full) begin 
                        valid_init_blk   <= ena_init_blk;
                        valid_bybz       <= valid_init_blk;
                        
                        if(flag_last_by & flag_last_bz) begin
                            is_upper <= ~is_upper;
                        end
                        
                        if(flag_last_bz) begin
                            init_bz      <= 0;
                        end
                        else if(flag_last_by) begin
                            init_bz++;
                            pointer <= 0;
                        end
                        else if(&flag_finish_read_blk) begin
                            pointer++;
                        end
                        
                        if(valid_init_blk) begin
                            offset[init_bz] <= dout_init_blk;
                        end
                    end
                end // case: INIT_BLK
                WRITE_BACK: begin
                    pointer <= 0;

                    if(valid_init_blk) begin
                        wb_addr <= {wb_bz,wb_by};
                        wb_bz++;
                    end
                    for(port=0; port<PORT_NUM; port=port+1) begin
                        // hbm_port = (bx%32 + by%32 + bz%32) % 32;
                        wb_hbm_port      [port] <= (wb_bx[port]%32) + wb_by[port][4:0] + wb_bz[port][4:0];
                        // hbm_addr = bx + 128*by + 128^2*(bz/32);
                        wb_tmp_hbm_addr  [port] <= {{wb_bz[port] >> 5}, wb_by[port], wb_bx[port]};
                        wb_hbm_addr      [wb_hbm_port[port]] <= wb_tmp_hbm_addr[port];
                    end
                end
            endcase
        end // else: !if(~resetn)
    end // always_ff @ (posedge clk)
    
    reg [ 6:0] blk_id;
    reg [ 2:0] j[PORT_NUM];
    wire [PORT_NUM-1:0]rlast;
    reg [PORT_NUM-1:0] flag_finish_read_blk;
    wire flag_last_blk;
    reg [PORT_NUM-1:0]blk_next;
    reg [PORT_NUM-1:0]addr_fifo_full;

    assign flag_last_blk = (blk_id >= BLOCK_LEN-1);

    genvar port;
    generate
        for(port=0; port<PORT_NUM; port++) begin
            assign flag_finish_read_blk[port] = rlast[port] && (j[port] == 5);
            always_ff @(posedge clk) begin
                
                if(~resetn) begin
                    j[port]        <= 0;
                    blk_next[port] <= 0;
                end 
                else begin
                    if(flag_finish_blk[port] && ~addr_fifo_full[port]) begin
                        blk_next[port] <= 1;
                    end
                    else if(ena_init_blk) begin
                        blk_next[port] <= 0;
                    end
                    
                    if(rlast[port] && (j[port] == 5)) begin
                        j[port] <= 0;
                    end 
                    else if(rlast[port]) begin
                        j[port]++;
                    end
                end // else: !if(~resetn)
            end // always_ff @ (posedge clk)
        end // for (port=0; port<PORT_NUM; port++)
    endgenerate

    reg [8:0] advance;
    wire flag_last_advance = (advance >= 511);

    always_ff @(posedge clk) begin
        if(~resetn) begin
            advance   <= 0;
            pointer   <= 0;
        end
        else begin
            if(flag_last_advance) begin
                advance <= 0;
                pointer <= init_pointer;
            end
            else if(flag_last_angle) begin
                advance++;

            end
        end
    end // always_ff @ (posedge clk)
    
    ////////////////////////
    // Control AXI3 Write //
    ////////////////////////

    //// AXI3 ////
    reg                       awvalid[PORT_NUM];
    reg                       awready[PORT_NUM];
    wire                      wvalid[PORT_NUM];
    reg  [LOG_DATA_DEPTH-1:0] awaddr[PORT_NUM];
    wire [1:0]                bresp[PORT_NUM];
    wire                      wready[PORT_NUM];

    generate 
        for(port=0; port<PORT_NUM; port=port+1) begin
            
            // Read Address
            //// in
            // 1 port 201,326,592 B -- address 29 bits -- burst log(16*256/8) = 9 bits
            assign axi3[port].awaddr  = {port, wb_hbm_addr[port], 9'b0};
            assign axi3[port].awvalid = awvalid;
            assign axi3[port].awburst = 2'b01;
            assign axi3[port].awlen   = 16;
            // awsize = log_2(DATA_WIDTH/8); 256/8 = 32 = 2^5;
            assign axi3[port].awsize  = 5;
            assign axi3[port].awid    = 0;
            //// out
            assign awready[port]      = axi3[port].arready;
            
            // Write Data
            //// in
            assign axi3[port].wvalid  = wvalid[port];
            assign axi3[port].wdata   = wb_hbm_wdata[port];
            assign axi3[port].wlast   = wlast[port];
            assign axi3[port].wid     = 0;
            assign axi3[port].wstrb   = {32{'b1}};
            assign axi3[port].bid     = 0;            
            assign axi3[port].bready  = 1;

            //// out
            assign wready[port]       = axi3[port].wready;
            assign bresp[port]        = axi3[port].bresp;

            assign bnext[port]   = (bresp[port] == 2'b00) & bvalid[port] & bready[port];
            
            //                    _   _   _   _   _   _   _   _   _   _   _   _   _
            // clk              _| |_| |_| |_| |_| |_| |_| |_| |_| |_| |_| |_| |_| |_
            //                    ___
            // blk_valid        _|   |______________________________________________
            //                        ___
            // arvalid          _____|   |________________________________________
            //                  __________________________________________________
            // hbm_addr/port    _____|addr/port____________________________________
            //                                _____________________________________
            // rnext            _____________| 
            //                  ____________________________________________________
            // hbm_rdata        _____________|d0_|d1_|d2_|d3_|d4_|d5_|d6_|d7_|d8_|
            //
            
        end // for (port=0; port<PORT_NUM; port=port+1)
    endgenerate
    
    //////////////////////////////
    // FIFO for a buffer of HBM //
    //////////////////////////////
    
    //                   +---- fifo[0] -- hbm_port[0]
    //                   |
    // dout_init_blk ----+---- fifo[1] -- hbm_port[1]
    //                   |
    //                   +---- fifo[2] -- hbm_port[2]
    //                   |
    //                   +---- ...
    //
    //                     _   _   _   _   _   _   _   _   _   _   _   _   _   _   
    // clk                | |_| |_| |_| |_| |_| |_| |_| |_| |_| |_| |_| |_| |_| |_
    //                    ____________________________________________________________
    // {init_by,bz}       ____|{by,bz}_________________________
    //                         ___
    // valid_bybz         ____|   |____________________________
    //                                         _______________________
    // hbm_arready[0]     ____________________|                       |_________
    //                    ________________________________________________________
    // fifo_bybz[port]    ________________________|{by[0],bz[0]}______________________
    //
    
    localparam FIFO_DEPTH = 16;
    reg [7:0] addr_fifo_bybz[FIFO_DEPTH][PORT_NUM];
    reg [3:0] addr_fifo_wp[PORT_NUM], addr_fifo_rp[PORT_NUM], addr_fifo_len[PORT_NUM];
    reg [3:0] by[PORT_NUM], bz[PORT_NUM];
    wire hbm_arready[PORT_NUM];
    reg [PORT_NUM-1:0] addr_fifo_empty;

    generate
        for(port=0; port<PORT_NUM; port++) begin
            assign hbm_arready[port] = axi3[port].arready;
            always_ff @(posedge clk) begin
                if(~resetn) begin
                    for(integer i=0; i<FIFO_DEPTH; i=i+1) begin
                        addr_fifo_bybz[i][port] <= 0;
                    end
                    addr_fifo_wp[port]                  <= 0;
                    addr_fifo_rp[port]                  <= 0;
                    addr_fifo_len[port]                 <= 0;                
                end
                else begin
                    if(valid_bybz) begin
                        addr_fifo_bybz[addr_fifo_wp[port]][port] <= {init_by,init_bz};
                        addr_fifo_wp[port]++;
                    end
                    if(hbm_arready[port]) begin
                        {by[port],bz[port]} <= addr_fifo_bybz[addr_fifo_rp[port]][port];
                        addr_fifo_rp[port]--;
                    end
                    
                    if(valid_bybz && ~hbm_arready[port]) 
                      addr_fifo_len[port]++;
                    else if(~bybz_valid && hbm_arready[port]) 
                      addr_fifo_len[port]--;
                    
                    if(addr_fifo_len[port] == 0) 
                      addr_fifo_empty[port] <= 1;
                    else 
                      addr_fifo_empty[port] <= 0;
                    
                    if(addr_fifo_len[port] >= FIFO_DEPTH)
                      addr_fifo_full[port] <= 1;
                    else 
                      addr_fifo_full[port] <= 0;
                end
            end // always_ff @ (posedge clk)
        end // for (port=0; port<PORT_NUM; port=port+1)
    endgenerate
    
    //////////////////////////////
    // Calculate address to HBM //
    //////////////////////////////
    
    reg [   4:0] hbm_port; // 32 port
    reg [19:0] hbm_addr; // 4*128^2
    reg [19:0] tmp_hbm_addr[PORT_NUM];
    reg [3:0] tmp_by[PORT_NUM];
    reg [1:0] k;
    
    //                 _   _   _   _   _   _   _  
    // clk           _| |_| |_| |_| |_| |_| |_| |_
    //                 ___
    // blk_valid     _|   |_______________________
    //               _____________________________
    // hbm_addr/port _____|addr/port______________
    //

    generate
        for(port=0; port<PORT_NUM; port=port+1) begin
            integer bx = port * q;
            always_ff @(posedge clk) begin
                if(~resetn) begin
                    hbm_port[port]  <= 0;
                    hbm_addr[port]  <= 0;
                end 
                else begin
                    if(~addr_fifo_empty[port]) begin
                        // hbm_port = (bx%32 + by%32 + bz%32) % 32;
                        hbm_port      [port] <= (bx[port]%32) + by[port][4:0] + bz[port][4:0];
                        // hbm_addr = bx + 128*by + 128^2*(bz/32);
                        tmp_hbm_addr  [port] <= {{bz[port] >> 5}, by[port], bx[port]};
                        hbm_addr      [hbm_port[port]] <= tmp_hbm_addr[port];
                    end
                end
            end // always_ff @ (posedge clk)
        end // for (bx=0; bx<PORT_NUM; bx=bx+1)
    endgenerate
    
    ///////////////////////
    // Control AXI3 read //
    ///////////////////////

    //// AXI3 ////
    reg                       arvalid[PORT_NUM];
    reg                       arready[PORT_NUM];
    wire                      rvalid[PORT_NUM];
    reg  [LOG_DATA_DEPTH-1:0] araddr[PORT_NUM];
    wire [1:0]                rresp[PORT_NUM];
    wire                       rready[PORT_NUM];
    wire [DATA_WIDTH-1:0]     hbm_rdata[PORT_NUM];

    //// control ////
    wire                      hbm_next[PORT_NUM];
    wire                      flag_next_burst = rlast;
    wire                      rnext[PORT_NUM];
    reg [3:0]                 count = 0;
    reg [255:0]               tmp_hbm_rdata[2];
    reg [PORT_NUM-1:0]        addr_fifo_full;
    reg [3:0] count_rnext[PORT_NUM];

    generate 
        for(port=0; port<PORT_NUM; port=port+1) begin
            
            // Read Address
            //// in
            // 1 port 201,326,592 B -- address 29 bits -- burst log(16*256/8) = 9 bits
            assign axi3[port].araddr  = {port, hbm_addr[port], 9'b0};
            assign axi3[port].arvalid = arvalid;
            assign axi3[port].arburst = 2'b01;
            assign axi3[port].arlen   = 16;
            // arsize = log_2(DATA_WIDTH/8); 256/8 = 32 = 2^5;
            assign axi3[port].arsize  = 5;
            assign axi3[port].arid    = 0;
            //// out
            assign arready[port]      = axi3[port].arready;
            
            // Read Data
            //// out
            assign rvalid[port]       = axi3[port].rvalid;
            assign hbm_rdata[port]    = axi3[port].rdata;
            assign rlast[port]        = axi3[port].rlast;
            assign rresp[port]        = axi3[port].rresp;
            //// in
            assign axi3[port].rready  = rready[port];
            assign axi3[port].rid     = 0;

            assign arvalid[port] = bybz_valid;
            assign rready[port]  = data_fifo_full[port];
            assign rnext[port]   = (rresp[port] == 2'b00) & rvalid[port] & rready[port];
            
            //                    _   _   _   _   _   _   _   _   _   _   _   _   _
            // clk              _| |_| |_| |_| |_| |_| |_| |_| |_| |_| |_| |_| |_| |_
            //                    ___
            // blk_valid        _|   |______________________________________________
            //                        ___
            // arvalid          _____|   |________________________________________
            //                  __________________________________________________
            // hbm_addr/port    _____|addr/port____________________________________
            //                                _____________________________________
            // rnext            _____________| 
            //                  ____________________________________________________
            // hbm_rdata        _____________|d0_|d1_|d2_|d3_|d4_|d5_|d6_|d7_|d8_|
            //
            
        end // for (port=0; port<PORT_NUM; port=port+1)
    endgenerate

    ////////////////////////////
    // fifo for HBM read data //
    ////////////////////////////
    
    reg [255:0] data_fifo[FIFO_DEPTH][PORT_NUM];
    reg [3:0] data_fifo_wp[PORT_NUM], data_fifo_rp[PORT_NUM], data_fifo_len[PORT_NUM];
    reg [255:0] aligned_data[PORT_NUM];
    wire is_aligned;
    reg [PORT_NUM-1:0] data_fifo_empty;

    //                      _   _   _   _   _   _   _   _   _   _   _   _   _   _   
    // clk                 | |_| |_| |_| |_| |_| |_| |_| |_| |_| |_| |_| |_| |_| |
    //                      ___         ___         ___                     ___
    // rnext[0]            |   |_______|   |_______|   |___________________|   |__
    //                     _______________________________________________________
    // count_rnext[0]      ____|3__________|4__________|5______________________|6_
    //                     _______________________________________________________
    // hbm_rdata[0]        |d0_________|d1_________|d2_____________________|d3____
    //                     
    // data_fifo_full[0]   _______________________________________________________
    //                     _______________________________________________________
    // data_fifo     [0]   ____|d0_________|d1_________|d2_____________________|d3
    //                     
    //                      _   _   _   _   _   _   _   _   _   _   _   _   _   _   
    // clk                 | |_| |_| |_| |_| |_| |_| |_| |_| |_| |_| |_| |_| |_| |
    //                          ___             ___         ___         ___
    // rnext[1]            ____|   |___________|   |_______|   |_______|   |______
    //                     _______________________________________________________
    // count_rnext[1]      ________|3______________|4__________|5__________|6_____
    //                     _______________________________________________________
    // hbm_rdata[1]        ____|d0_____________|d1_________|d2_________|d3________
    //                              _______
    // data_fifo_full[1]   ________|       |______________________________________
    //                     _______________________________________________________
    // data_fifo_out[1]    ________|d0_____________|d1_________|d2_________|d3____
    //                     
    //                      _   _   _   _   _   _   _   _   _   _   _   _   _   _
    // clk                 | |_| |_| |_| |_| |_| |_| |_| |_| |_| |_| |_| |_| |_| |
    //                              ___             ___         ___             __
    // is_aligned          ________|   |___________|   |_______|   |___________|  
    //                     _______________________________________________________
    // aligned_data[0]/[1] ____________|d0_____________|d1_________|d2____________
    //                                  ___             ___         ___            
    // aligned_valid       ____________|   |___________|   |_______|   |__________
    //
    
    assign is_aligned = count_rnext[ 0] == count_rnext[ 1] == count_rnext[ 2] == count_rnext[ 3]
                     == count_rnext[ 4] == count_rnext[ 5] == count_rnext[ 6] == count_rnext[ 7]
                     == count_rnext[ 8] == count_rnext[ 9] == count_rnext[10] == count_rnext[11]
                     == count_rnext[12] == count_rnext[13] == count_rnext[14] == count_rnext[15]
                     == count_rnext[16] == count_rnext[17] == count_rnext[18] == count_rnext[19]
                     == count_rnext[20] == count_rnext[21] == count_rnext[22] == count_rnext[23]
                     == count_rnext[24] == count_rnext[25] == count_rnext[26] == count_rnext[27]
                     == count_rnext[28] == count_rnext[29] == count_rnext[30] == count_rnext[31];

    generate
        for(port=0; port<PORT_NUM; port++) begin
            assign hbm_arready[port] = axi3[port].arready;
            always_ff @(posedge clk) begin
                if(~resetn) begin
                    for(integer i=0; i<FIFO_DEPTH; i++) begin
                        data_fifo[i][port] <= 0;
                    end
                    data_fifo_wp[port]   <= 0;
                    data_fifo_rp[port]   <= 0;
                    data_fifo_len[port]  <= 0;                
                end
                else begin
                    if(rnext[port]) begin
                        data_fifo[data_fifo_wp[port]][port] <= hbm_rdata[port];
                        data_fifo_wp[port]++;
                    end
                    
                    if(is_aligned) begin
                        aligned_data[port] <= data_fifo[data_fifo_rp[port]][port];
                        data_fifo_rp[port]++;
                    end
                    
                    if(rnext[port] && ~is_aligned)
                      data_fifo_len[port]++;
                    else if(~rnext[port] && is_aligned)
                      data_fifo_len[port]--;
                    
                    if(data_fifo_len[port] == 0)
                      data_fifo_empty[port]  <= 1;
                    else
                      data_fifo_empty[port]  <= 0;
                    
                    if(data_fifo_len[port] >= FIFO_DEPTH)
                      data_fifo_full[port]   <= 1;
                    else
                      data_fifo_full[port]   <= 0;
                end
            end
        end // for (port=0; port<PORT_NUM; port++)
    endgenerate

    ///////////////////////////////////////////
    // bit split from hbm data block to mesh //
    ///////////////////////////////////////////

    reg [5:0]   data_fifo_count[PORT_NUM];
    reg [383:0] mesh_data[PORT_NUM];
    reg         mesh_data_en[PORT_NUM];
    
    //                    _   _   _   _   _   _   _   _   _   _   _   _   _   _
    // clk              _| |_| |_| |_| |_| |_| |_| |_| |_| |_| |_| |_| |_| |_| |
    //                  ________________________________________________________
    // aligned_data     _|d0_|d1_|u______|d2_|d3_|d4_|d5_|d6_|d7_|d8_|u_________
    //                    _______         ___________________________
    // is_aligned       _|       |_______|                           |__________
    //                  ________________________________________________________
    // data_fifo_count  _____|1__|2__________|3__|4__|5__|6__|7__|8__|9_____________
    //                  ____________________________________________
    // mesh_data        _u___|m0_|m1_|u__|m2_|m3_|u__|m4_|m5_|u__|m6|
    //                            ___     ___             ___     ___
    // mesh_data_en     _________|   |___|   |___________|   |___|
    //
    
    always_ff @(posedge clk) begin
        if (~resetn) begin
            data_fifo_count[port]    <= 0;
            mesh_data_en[0]          <= 0;
            mesh_data_en[1]          <= 0;
        end
        else if(is_aligned) begin
            if(data_fifo_count < 48) begin
                data_fifo_count++;
            end
            
            if(data_fifo_count%3==0) begin
                mesh_data_en[0]       <= 0;
                mesh_data_en[1]       <= 0;
            end
            else if(data_fifo_count%3==1) begin
                mesh_data_en[0]       <= 1;
                mesh_data_en[1]       <= 0;
            end
            else if(data_fifo_count%3==2) begin
                mesh_data_en[0]       <= 0;
                mesh_data_en[1]       <= 1;
            end
        end // if (is_aligned)
    end // always_ff @ (posedge clk)
    
    generate
        for(port=0; port<32; port++) begin
            always_ff @(posedge clk) begin
                if (~resetn) begin
                    mesh_data[port][1]             <= 0;
                    mesh_data[port][0]             <= 0;
                end
                else if(is_aligned) begin
                    if(data_fifo_count%3==0) begin
                        mesh_data[port][0][383:128] <= aligned_data[port][255:  0];
                    end
                    else if(data_fifo_count%3==1) begin
                        mesh_data[port][0][127:  0] <= aligned_data[port][255:128];
                        mesh_data[port][1][255:128] <= aligned_data[port][127:  0];
                    end
                    else if(data_fifo_count%3==2) begin
                        mesh_data[port][1][127:  0] <= aligned_data[port][255:  0];
                    end
                end // if (is_aligned)
            end // always_ff @ (posedge clk)
        end // for (port=0; port<32; port++)
    endgenerate

    ////////////////////////
    // Accumulate on URAM //
    ////////////////////////

    //                         _______     _______     _______
    // mesh_data_en  _________|       |___|       |___|       |
    //               _________________________________________
    // mesh_data     _u_______|m0_|m1_|u__|m2_|m3_|u__|m4_|m5_
    //               ____________________________________________
    // count_mesh    _________|1__|2______|3__|4______|5__|6_____
    //               ____________________________________________
    // spm_addra     __U__|a0_|a1_|a2_____|a3_|a4_|a5_|a6_|a7_|__
    //               ____________________________________________    
    // spm_dina      __U__|d0_|d1_|d2_____|d3_|d4_|d5_|d6_|d7_|__
    //

    reg  [  11:0] count_mesh;

    genvar spm_id; // 128 = 16*8mesh
    generate
        for(spm_id=0; spm_id<16; spm_id=spm_id+1) begin
            assign spm[spm_id].addra = count_mesh; // max 64*40=2560
            assign spm[spm_id].dina  = {mesh_data[0+spm_id*8], mesh_data[1+spm_id*8],
                                        mesh_data[2+spm_id*8], mesh_data[3+spm_id*8],
                                        mesh_data[4+spm_id*8], mesh_data[5+spm_id*8], 
                                        mesh_data[6+spm_id*8], mesh_data[7+spm_id*8]};
            assign spm[spm_id].ena = mesh_data_en[0] | mesh_data_en[1];

            always_ff @(posedge clk) begin
                if(~resetn)
                    count_mesh <= 0;
                else if(spm[0].ena)
                    count_mesh++;
            end
        end // for (uram_id=0; uram_id<16; uram_id=uram_id+1)
    endgenerate

    /////////////////
    // Control SPM //
    /////////////////


    
    /////////////////////////////
    // Write back oldest block //
    /////////////////////////////

    reg wb_addr;

    always_ff @(posedge clk) begin
        if(flag_last_angle) begin
            wb_addr <=;
        end
    end
    
    hbm_0 hbm_0_inst 
      (
       .APB_0_PCLK         (clk_100            ),
       .APB_0_PRESET_N     (resetn             ),
       .apb_complete_0     (                   ),
       .DRAM_0_STAT_CATTRIP(                   ),
       .DRAM_0_STAT_TEMP   (                   ),
       .HBM_REF_CLK_0      (clk_450            ),
       .AXI_00_ACLK        (clk_450            ),
       .AXI_00_ARESET_N    (aresetn_450        ),
       .AXI_00_ARADDR      (axi3[0].araddr     ),
       .AXI_00_ARBURST     (axi3[0].arburst    ),
       .AXI_00_ARID        (axi3[0].arid       ),
       .AXI_00_ARLEN       (axi3[0].arlen      ),
       .AXI_00_ARSIZE      (axi3[0].arsize     ),
       .AXI_00_ARVALID     (axi3[0].arvalid    ),
       .AXI_00_AWADDR      (axi3[0].awaddr     ),
       .AXI_00_AWBURST     (axi3[0].awburst    ),
       .AXI_00_AWID        (axi3[0].awid       ),
       .AXI_00_AWLEN       (axi3[0].awlen      ),
       .AXI_00_AWSIZE      (axi3[0].awsize     ),
       .AXI_00_AWVALID     (axi3[0].awvalid    ),
       .AXI_00_RREADY      (axi3[0].rready     ),
       .AXI_00_BREADY      (axi3[0].bready     ),
       .AXI_00_WDATA       (axi3[0].wdata      ),
       .AXI_00_WLAST       (axi3[0].wlast      ),
       .AXI_00_WSTRB       (axi3[0].wstrb      ),
       .AXI_00_WDATA_PARITY(                   ), 
       .AXI_00_WVALID      (axi3[0].wvalid     ),
       .AXI_00_ARREADY     (axi3[0].arready    ),
       .AXI_00_AWREADY     (axi3[0].awready    ),
       .AXI_00_RDATA_PARITY(                   ), 
       .AXI_00_RDATA       (axi3[0].rdata      ),
       .AXI_00_RID         (axi3[0].rid        ),
       .AXI_00_RLAST       (axi3[0].rlast      ),
       .AXI_00_RRESP       (axi3[0].rresp      ),
       .AXI_00_RVALID      (axi3[0].rvalid     ),
       .AXI_00_WREADY      (axi3[0].wready     ),
       .AXI_00_BID         (axi3[0].bid        ),
       .AXI_00_BRESP       (axi3[0].bresp      ),
       .AXI_00_BVALID      (axi3[0].bvalid     ),
       .AXI_01_ACLK        (clk_450            ),
       .AXI_01_ARESET_N    (aresetn_450        ),
       .AXI_01_ARADDR      (axi3[1].araddr     ),
       .AXI_01_ARBURST     (axi3[1].arburst    ),
       .AXI_01_ARID        (axi3[1].arid       ),
       .AXI_01_ARLEN       (axi3[1].arlen      ),
       .AXI_01_ARSIZE      (axi3[1].arsize     ),
       .AXI_01_ARVALID     (axi3[1].arvalid    ),
       .AXI_01_AWADDR      (axi3[1].awaddr     ),
       .AXI_01_AWBURST     (axi3[1].awburst    ),
       .AXI_01_AWID        (axi3[1].awid       ),
       .AXI_01_AWLEN       (axi3[1].awlen      ),
       .AXI_01_AWSIZE      (axi3[1].awsize     ),
       .AXI_01_AWVALID     (axi3[1].awvalid    ),
       .AXI_01_RREADY      (axi3[1].rready     ),
       .AXI_01_BREADY      (axi3[1].bready     ),
       .AXI_01_WDATA       (axi3[1].wdata      ),
       .AXI_01_WLAST       (axi3[1].wlast      ),
       .AXI_01_WSTRB       (axi3[1].wstrb      ),
       .AXI_01_WDATA_PARITY(                   ), 
       .AXI_01_WVALID      (axi3[1].wvalid     ),
       .AXI_01_ARREADY     (axi3[1].arready    ),
       .AXI_01_AWREADY     (axi3[1].awready    ),
       .AXI_01_RDATA_PARITY(                   ), 
       .AXI_01_RDATA       (axi3[1].rdata      ),
       .AXI_01_RID         (axi3[1].rid        ),
       .AXI_01_RLAST       (axi3[1].rlast      ),
       .AXI_01_RRESP       (axi3[1].rresp      ),
       .AXI_01_RVALID      (axi3[1].rvalid     ),
       .AXI_01_WREADY      (axi3[1].wready     ),
       .AXI_01_BID         (axi3[1].bid        ),
       .AXI_01_BRESP       (axi3[1].bresp      ),
       .AXI_01_BVALID      (axi3[1].bvalid     )
       );
    
endmodule
