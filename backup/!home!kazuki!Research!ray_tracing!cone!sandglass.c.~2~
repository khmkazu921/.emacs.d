#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <math.h>
#include <string.h>
#include <limits.h>
#include <float.h>
#include <omp.h>
#include "ray_tracing.h"

int healpix[6][N_ANG/RAY_CONE_NUM] = {0};

int main(void){
    double diffphi = 0.0;
//  omp_set_num_threads(16);
//#pragma omp parallel for private(x, diffphi, ipix4)
    struct run_param *this_run;
    struct host_diffuse_param *hd_param;
    this_run = (struct run_param*)malloc(sizeof(struct run_param));
    assert( this_run );
    this_run->rank_x  = this_run->rank_y  = this_run->rank_z = 0;
    this_run->nnode_x = this_run->nnode_y = this_run->nnode_z = 1;
    hd_param = (struct host_diffuse_param*)malloc(RAY_CONE_NUM*sizeof(struct host_diffuse_param));
        
    setup_data(this_run);
    init_hd_param(hd_param);
    set_angle_info(hd_param, &diffphi); 

    for(int ig = 0; ig < hd_param->angle[N_ANG-1].group_id; ig++) {
        zero_set_rmesh(hd_param->rmesh);
        printf("ig %d \n",ig);
        ray_tracing(ig, hd_param, this_run);

        //break;
    } //ipix4 loop
    
    free(this_run);
    free(hd_param->step_fact);
    //free(hd_param->angle);
    free(hd_param->rmesh);
    free(hd_param);   
    return 0;
}


void search_partition(int *array, int point, int *partition) {
    for(int j=0; j<NMESH_X_LOCAL; j++) {
        int max = -1;
        for(int i=0; i<point; i++) {
            int gap;
            if(i == point-1)
                gap = NMESH_X_LOCAL + array[0] - array[point-1];
            else
                gap = array[i+1] - array[i];
            if(max < gap) {
                partition[j] = i+1;
                max = gap;
            }
            //printf("gap[%d]=%d max[%d]=%d|",i,gap,*partition,max);
        }
    }
}

int compensation(int*array, int point, int *partition)
{
    printf("compensation\n");
    for(int j=0; j<point; j++) printf("%4d ",array[j]);
    printf("\n");
    int p = 0;
    for(int i=0; i<NMESH_X_LOCAL; i++) {
        int min = array[p];
        int max = min;
        int l = 0;
        if(array[p] >= (i+1)*NMESH_XY_LOCAL) continue;
        if(p == point) break;
        printf("\ni %d min %d p2 %d max %d pointer %d l %d partition %d\n",i,min,p,max,point,l,partition[i]);
        
        if(partition[i]!=0) {
            min = array[p+partition[i]];
            max = NMESH_X_LOCAL + array[p+partition[i]-1];
        }

        int len = max-min-1; // length of append[]
        int shift = len-l+2; // shift
        printf("\ni %d min %d p2 %d shift %d max %d len %d pointer %d l %d partition %d\n",i,min,p,shift,max,len,point,l,partition[i]);
        if(len > 0) {
            int *append = (int*)malloc(sizeof(int)*len);
            for(int j=1; j<=len; j++) append[j-1] = min + j;
            /* printf("\n pointer1 %d \n", point); */
            void *start = array + shift + p;
            void *thrustin = array + p;
            int copy = point - p;
            memmove(start, thrustin, copy*sizeof(int));
            memmove(array+p+1, append, len*sizeof(int));
            point += shift;
            //printf("\n pointer2 %d \n", point); 
            free(append);
        }
        p += len+2;

    }
    return point;
}

void search_column(array, column) {
    int p=0;
    for(int i=0; i<NMESH_X_LOCAL; i++) {
        for(int j=p; j<point; j++) {
            //printf("j=%d p=%d point=%d array[%d]=%d\n",j,p,point,j,array[j]);
            if(array[j]<(i+1)*NMESH_XY_LOCAL){
                max = array[j];
            }
            else break;
        }
        
    }
}
    
    
void make_sandgrass(int* spm_id, int* pointer)
{
    for(int layer=0; layer<NMESH_X_LOCAL; layer++) {
        int point = pointer[layer];
        int array[NMESH_XY_LOCAL];
        int low = layer*NMESH_XY_LOCAL;
        int partition[NMESH_X_LOCAL] = {-1};
        memcpy(array, &spm_id[low], point*sizeof(int));
        quick_sort(array, 0, point-1);
        point = array_unique(array, 0, point-1);

        search_partition(array, point, partition);
        point = compensation(array, point, partition);
        for(int j=0; j<point; j++) {
            printf("%3d ",array[j]);
            //printf("+");
        }
        printf("\n");
        memmove(&spm_id[low], array, point*sizeof(int));
        pointer[layer] = point;
    }
}

void ray_tracing(int ig, struct host_diffuse_param *hd_param, struct run_param *t)
{
    struct ray_info *iray;
    iray = (struct ray_info*)malloc(sizeof(struct ray_info));
    assert(iray);

    struct geometric_var *g;
    g = (struct geometric_var*)malloc(sizeof(struct geometric_var));

    int *spm_id = (int*)malloc(sizeof(int)*NMESH_X_LOCAL*NMESH_XY_LOCAL);
    assert(spm_id);
    memset(spm_id, -1, NMESH_X_LOCAL*NMESH_XY_LOCAL);
    
    int pointer[NMESH_X_LOCAL];
    memset(pointer, 0, sizeof(int)*NMESH_X_LOCAL);
    
    int ipix = 0;
    for(int i=0; i<ig; i++) 
        ipix += hd_param->num_group_id[i];

    int num_group_id = hd_param->num_group_id[ig];
    
    for(int i=0; i<num_group_id; i++) {
        struct angle_info *a = &hd_param->angle[ipix + i];
        set_ray_start_position(iray, a, t);
        art_initialise(g, iray, a, t);

        if ( (g->ix_cur >= NMESH_X_LOCAL) ||
             (g->iy_cur >= NMESH_Y_LOCAL) ||
             (g->iz_cur >= NMESH_Z_LOCAL) ||
             (g->ix_cur < 0) ||
             (g->iy_cur < 0) ||
             (g->iz_cur < 0) )
            continue;
        //printf("[%d] ", hd_param->angle[ipix+i].base_id);
        while(1) {
            //printf("%f %f %f %d/%d \n", iray->x, iray->y, iray->z, i, num_group_id);
            int return_val = 0;
            art_geometric(g, iray, a->base_id, pointer, spm_id);
            //art_while_inner(iray, t, g, c, hd_param->rmesh);
            ray_cycle(a->base_id, iray, t, g, &return_val);
            if (return_val) break;
        } //while loop
    } // cone
    
    /* printf("base_id %d\n",hd_param->angle[ipix].base_id); */
    make_sandgrass(spm_id, pointer);

    /* for(int i=0; i<NMESH_X_LOCAL; i++) { */
    /*     printf("layer %2d [%3d] : ",i,pointer[i]); */
    /*     for(int j=0; j<pointer[i]-1; j++) { */
    /*         //printf("%3d ",spm_id[i*NMESH_XY_LOCAL+j]); */
    /*         printf("+"); */
    /*     } */
    /*     printf("\n"); */
    /* } */

    free(iray); free(g); free(spm_id);
}

void art_geometric(struct geometric_var *g, struct ray_info *iray, int base_id, int *pointer, int *spm_id)
{
    g->pos = g->ix_cur + NMESH_Z_LOCAL*g->iy_cur + NMESH_X_LOCAL*NMESH_Y_LOCAL*g->iz_cur;

    //printf("%d %d %d\n",g->ix_cur,g->iy_cur ,g->iz_cur);
    
    int layer, p;
    switch(base_id) {
    case 0: case 1:
        layer = g->iz_cur;
        p = layer * NMESH_XY_LOCAL + pointer[layer]++;
        spm_id[p] = g->ix_cur + NMESH_Z_LOCAL*g->iy_cur;
        break;
    case 2: case 3:
        layer = g->ix_cur;
        p = layer * NMESH_XY_LOCAL+ pointer[layer]++;
        spm_id[p] = g->iy_cur + NMESH_Z_LOCAL*g->iz_cur;
        break;
    case 4: case 5:
        layer = g->iy_cur;
        p = layer * NMESH_XY_LOCAL + pointer[layer]++;
        spm_id[p] = g->iz_cur + NMESH_Z_LOCAL*g->ix_cur;
        break;
    default:
        exit(1);
    }
    /* if(spm_id[p]==0)printf("cur %d %d %d layer %d\n",g->ix_cur,g->iy_cur,g->iz_cur,layer); */
//    if(pointer[layer]-1 >= RAY_CONE_NUM*2) pointer[layer] = 0;

    if (g->keep_zr <= g->keep_xr && g->keep_zr <= g->keep_yr) {
        g->rmin = g->keep_zr - g->current_r;
        g->current_r = g->keep_zr;
        g->keep_zr += g->step_zr;
        g->iz_cur += (g->zovr > 0.0e0f) ? 1 : -1;
    } else if (g->keep_yr <= g->keep_xr && g->keep_yr <= g->keep_zr) {
        g->rmin = g->keep_yr - g->current_r;
        g->current_r = g->keep_yr;
        g->keep_yr += g->step_yr;
        g->iy_cur += (g->yovr > 0.0e0f) ? 1 : -1;
    } else if(g->keep_xr <= g->keep_yr && g->keep_xr <= g->keep_zr) {
        g->rmin = g->keep_xr - g->current_r;
        g->current_r = g->keep_xr;
        g->keep_xr += g->step_xr;
        g->ix_cur += (g->xovr > 0.0e0f) ? 1 : -1;
    }
    iray->x = g->start_x + g->current_r * g->xovr;
    iray->y = g->start_y + g->current_r * g->yovr;
    iray->z = g->start_z + g->current_r * g->zovr;           
}

void ray_cycle(short base_id, struct ray_info *iray, struct run_param *t, struct geometric_var *g, int *return_val)
             
{    
    if ( (g->ix_cur >= NMESH_X_LOCAL) ||
         (g->iy_cur >= NMESH_Y_LOCAL) ||
         (g->iz_cur >= NMESH_Z_LOCAL) ||
         (g->ix_cur < 0) ||
         (g->iy_cur < 0) ||
         (g->iz_cur < 0)) {

        iray->I_inHI = 0.0e0f;

        switch(base_id){
        case(0): case(1): //xy
            if(g->ix_cur >= NMESH_X_LOCAL) {
                g->start_x -= NMESH_X_LOCAL*t->delta_x;
                g->ix_cur = 0;
                iray->x = t->xmin_local;
            }
            else if(g->ix_cur < 0) {
                g->start_x += NMESH_X_LOCAL*t->delta_x;
                g->ix_cur = NMESH_X_LOCAL-1;
                iray->x = t->xmax_local;
            }
            if(g->iy_cur >= NMESH_Y_LOCAL) {
                g->start_y -= NMESH_Y_LOCAL*t->delta_y;
                g->iy_cur = 0;
                iray->y = t->ymin_local;
            }
            else if(g->iy_cur < 0) {
                g->start_y += NMESH_Y_LOCAL*t->delta_y;
                g->iy_cur = NMESH_Y_LOCAL-1;
                iray->y = t->ymax_local;
            }
            break;
        case(2): case(3): //yz
            if(g->iy_cur >= NMESH_Y_LOCAL) {
                g->start_y -= NMESH_Y_LOCAL*t->delta_y;
                g->iy_cur = 0;
                iray->y = t->ymin_local;
            }
            else if(g->iy_cur < 0) {
                g->start_y += NMESH_Y_LOCAL*t->delta_y;
                g->iy_cur = NMESH_Y_LOCAL-1;
                iray->y = t->ymax_local;                
            }
            if(g->iz_cur >= NMESH_Z_LOCAL) {
                g->start_z -= NMESH_Z_LOCAL*t->delta_z;
                g->iz_cur = 0;
                iray->z = t->zmin_local;
            }
            else if(g->iz_cur < 0) {
                g->start_z += NMESH_Z_LOCAL*t->delta_z;
                g->iz_cur = NMESH_Z_LOCAL-1;
                iray->z = t->zmax_local;
            }
            break;  //break switch (2)(3)
        case(4): case(5): //zx
            if(g->iz_cur >= NMESH_Z_LOCAL) {
                g->start_z -= NMESH_Z_LOCAL*t->delta_z;
                g->iz_cur = 0;
                iray->z = t->zmin_local;
            }
            else if(g->iz_cur < 0) {
                g->start_z += NMESH_Z_LOCAL*t->delta_z;
                g->iz_cur = NMESH_Z_LOCAL-1;
                iray->z = t->zmax_local;
            }
            if(g->ix_cur >= NMESH_X_LOCAL) {
                g->start_x -= NMESH_X_LOCAL*t->delta_x;
                g->ix_cur = 0;
                iray->x = t->xmin_local;
            }	    
            else if(g->ix_cur < 0) {
                g->start_x += NMESH_X_LOCAL*t->delta_x;
                g->ix_cur = NMESH_X_LOCAL-1;
                iray->x = t->xmax_local;
            }      
            break;  //break switch (4)(5)
        } // end switch
        if ( (g->ix_cur >= NMESH_X_LOCAL) ||
             (g->iy_cur >= NMESH_Y_LOCAL) ||
             (g->iz_cur >= NMESH_Z_LOCAL) ||
             (g->ix_cur < 0) ||
             (g->iy_cur < 0) ||
             (g->iz_cur < 0)) *return_val = 1;
    }
}

void art_initialise(struct geometric_var *g, struct ray_info *iray,
                    struct angle_info *a, struct run_param *t)
{
    float lc_offset_x,lc_offset_y,lc_offset_z; // offset of local block offset
    float ms_offset_x,ms_offset_y,ms_offset_z; // offset of mesh offset
    float roffset_x,roffset_y,roffset_z;    
    g->xovr = a->xovr;
    g->yovr = a->yovr;
    g->zovr = a->zovr;
    
    g->start_x = iray->x;
    g->start_y = iray->y;
    g->start_z = iray->z;
    
    lc_offset_x = iray->x - t->xmin_local;
    lc_offset_y = iray->y - t->ymin_local;
    lc_offset_z = iray->z - t->zmin_local;
    //printf("iray %f %f %f\n", iray->x, iray->y, iray->z);
    //printf("lc_offset %f : %f : %f \n", lc_offset_x, lc_offset_y, lc_offset_z);
        
    g->ix_cur = lc_offset_x/t->delta_x;
    g->iy_cur = lc_offset_y/t->delta_y;
    g->iz_cur = lc_offset_z/t->delta_z;
    //printf("ir_cur %d : %d : %d \n", g->ix_cur , g->iy_cur, g->iz_cur);

    //start point is grid point.
    if( g->xovr < 0.0e0f && g->ix_cur==NMESH_X_LOCAL) --g->ix_cur;
    if( g->yovr < 0.0e0f && g->iy_cur==NMESH_Y_LOCAL) --g->iy_cur;
    if( g->zovr < 0.0e0f && g->iz_cur==NMESH_Z_LOCAL) --g->iz_cur;
    
    ms_offset_x = lc_offset_x - t->delta_x*(float)g->ix_cur;
    ms_offset_y = lc_offset_y - t->delta_y*(float)g->iy_cur;
    ms_offset_z = lc_offset_z - t->delta_z*(float)g->iz_cur;
    //printf("ms_offset %f : %f : %f \n", ms_offset_x, ms_offset_y, ms_offset_z);
    
    g->step_xr = fabsf(t->delta_x / g->xovr); // always+
    g->step_yr = fabsf(t->delta_y / g->yovr);
    g->step_zr = fabsf(t->delta_z / g->zovr);
    
    //printf("delta %f %f %f\n", delta_x, delta_y, delta_z);
    //printf("step_r %f  %f  %f \n", g->step_xr, g->step_yr, g->step_zr);

    // true : false
    if(g->xovr > 0.0e0f)
        roffset_x = ms_offset_x / g->xovr;
    else
        roffset_x = (ms_offset_x != 0.0f) ?  (ms_offset_x - t->delta_x) / g->xovr : 0.0f;
    if(g->yovr > 0.0e0f)
        roffset_y = ms_offset_y / g->yovr;
    else
        roffset_y = (ms_offset_y != 0.0f) ?  (ms_offset_y - t->delta_y) / g->yovr : 0.0f;
    if(g->zovr > 0.0e0f)
        roffset_z = ms_offset_z / g->zovr;
    else
        roffset_z = (ms_offset_z != 0.0f) ?  (ms_offset_z - t->delta_z) / g->zovr : 0.0f;
    //printf("roffset %f : %f : %f \n", roffset_x, roffset_y, roffset_z);
    
    g->keep_xr = -roffset_x + g->step_xr; // always +
    g->keep_yr = -roffset_y + g->step_yr;
    g->keep_zr = -roffset_z + g->step_zr;
    //printf("keep_r %f %f %f\n", keep_xr, keep_yr, keep_zr);
    g->current_r = 0;
    
    //printf("ovr %f %f %f\n",g->xovr,g->yovr,g->zovr);
}

void art_while_inner(struct ray_info *iray, struct run_param *t, struct geometric_var *g,
                     struct calculation_var *c, struct radiation_mesh *rmesh)
{
    c->tau               = rmesh[g->pos].absorptionHI * ( g->rmin * t->lunit );
    c->etau              = exp(-c->tau);
    c->etaum1            = -expm1(-c->tau);
    rmesh[g->pos].IHI   += iray->I_inHI*c->etaum1;
    rmesh[g->pos].tauHI += c->tau;
    iray->I_inHI         = iray->I_inHI*c->etau + rmesh[g->pos].source_funcHI*c->etaum1;
}
