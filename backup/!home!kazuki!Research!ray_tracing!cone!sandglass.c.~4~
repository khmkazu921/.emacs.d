#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <math.h>
#include <string.h>
#include <limits.h>
#include <float.h>
#include <omp.h>
#include "ray_tracing.h"

int healpix[6][N_ANG/RAY_CONE_NUM] = {0};

int main(void){
    double diffphi = 0.0;
//  omp_set_num_threads(16);
//#pragma omp parallel for private(x, diffphi, ipix4)
    struct run_param *this_run;
    struct host_diffuse_param *hd_param;
    this_run = (struct run_param*)malloc(sizeof(struct run_param));
    assert( this_run );
    this_run->rank_x  = this_run->rank_y  = this_run->rank_z = 0;
    this_run->nnode_x = this_run->nnode_y = this_run->nnode_z = 1;
    hd_param = (struct host_diffuse_param*)malloc(RAY_CONE_NUM*sizeof(struct host_diffuse_param));
        
    setup_data(this_run);
    init_hd_param(hd_param);
    set_angle_info(hd_param, &diffphi); 

    for(int ig = 0; ig <= hd_param->angle[N_ANG-1].group_id; ig++) {
        //ig = 71;
        zero_set_rmesh(hd_param->rmesh);
        printf("\nig %d \n",ig);
        ray_tracing(ig, hd_param, this_run);

        break;
    } //ipix4 loop
    
    free(this_run);
    free(hd_param->step_fact);
    //free(hd_param->angle);
    free(hd_param->rmesh);
    free(hd_param);   
    return 0;
}


void search_partition(int *array, int col_len, int *partition) {
    *partition = 0;
    int gap = NMESH_X_LOCAL + array[0] - array[col_len-1];
    int max = gap;
    for(int i=0; i<col_len; i++) {
        printf("%d ",array[i]);
    }
    for(int i=1; i<col_len; i++) {
        gap = array[i] - array[i-1];
        if(max < gap) {
            *partition = i;
            max = gap;
        }
    }
    
    printf("max %d partition %d \n", max, *partition);
}

void low_compensation(int min, int max, int* col, int *col_len) {
    int len = max-min+1;
    int shift = len-*col_len;
    if(shift == 0) return;

    int append[len];
    for(int j=0; j<len; j++) append[j] = min + j;
    //printf("shift=%d col_len=%d\n",shift, *col_len);
    
    memmove(col+shift-1, col, *col_len*sizeof(int));
    memmove(col, append, len*sizeof(int)); // SIGSEGV
    *col_len += shift;
    // printf("###col_len=%d\n",*col_len);
}
   
void compensation(int*col, int *col_len, int *partition)
{
    /* printf("\n"); */
    /* for(int j=0; j<*col_len; j++) printf("%3d ",col[j]); */
    /* printf("\n"); */
    if(*partition == 0) {
        low_compensation(col[0], col[*col_len-1], col, col_len);
    } else {
        int upper = *col_len - *partition;
        low_compensation(col[*partition], col[*col_len-1], col, &upper);
        int lower = *partition;
        low_compensation(col[0], col[*partition-1], col, &lower);
        *col_len = upper + lower;
        //printf("###");
    }
    /* printf("compensation\n"); */
//    for(int j=0; j<*col_len; j++) printf("%4d ",col[j]);
    /* printf("\n"); */
}

void search_column(int *array, int* column, int layer_size) {
    int p = 0;
    for(int i=0; i<NMESH_X_LOCAL; i++) {
        int count = 0;
        while(1) {
            if(array[p]>=(i+1)*NMESH_X_LOCAL) break;
            if(p >= layer_size) break;
            p++; count++;
        }
        column[i] = count;
    }
}
    
void make_sandgrass(int* spm_id, int* pointer)
{
    for(int layer=0; layer<NMESH_X_LOCAL; layer++) {
        int layer_size = pointer[layer];
        int array[NMESH_XY_LOCAL];
        int low = layer*NMESH_XY_LOCAL;
        int partition[NMESH_X_LOCAL] = {-1};
        int col_len[NMESH_X_LOCAL] = {-1};
        memcpy(array, &spm_id[low], layer_size*sizeof(int));
        quick_sort(array, 0, layer_size-1);
        layer_size = array_unique(array, 0, layer_size-1);
        search_column(array, col_len, layer_size);

        /* printf("\n"); */
        printf("[%d] ",layer);
        for(int j=0; j<layer_size; j++) {
            printf("%3d ",array[j]);
            //printf("+");
        }
        printf("\n");

        /* int p=0; */
        /* for(int i=0; i<NMESH_X_LOCAL; i++) { */
        /*     if(col_len[i]<1) continue; */
        /*     for(int j =0; j<col_len[i]; j++) { */
        /*         printf("%d ",array[p+j]); */
        /*     } */
        /*     p += col_len[i]; */
        /*     printf("\n"); */
        /* } */
        
        int p=0;
        for(int i=0; i<NMESH_X_LOCAL; i++) { // every column
            int tmp = col_len[i];
            printf("[%2d](len%2d) ",i,col_len[i]);
            
            if(col_len[i] == 0) {
                printf("\n");
                continue;
            }
            if(col_len[i] == 1) {
                printf("%d\n",array[p]);
                p++;
                continue;
            }

            int col[NMESH_X_LOCAL];
            memcpy(col, &array[p], col_len[i]*sizeof(int));
            search_partition(col, col_len[i], &partition[i]);
            compensation(col, &col_len[i], &partition[i]);
            
            int shift = col_len[i] - tmp;
            //printf("shift %d\n",shift);

            /* printf("\ncol "); */
            /* for(int j=0; j<col_len[i]; j++) printf("%2d ",col[j]); */
            //printf("\n");
            
            memmove(&array[p+shift], &array[p], (layer_size-p)*sizeof(int));
            memmove(&array[p], col, col_len[i]*sizeof(int));
            layer_size += shift;
            p += col_len[i];
        }
      
        for(int j=0; j<p; j++) {
            printf("%3d ",array[j]);
            //printf("+");
        }
        printf("\n");
        //break;
        pointer[layer] = layer_size;
    }
}

void ray_tracing(int ig, struct host_diffuse_param *hd_param, struct run_param *t)
{
    struct ray_info *iray;
    iray = (struct ray_info*)malloc(sizeof(struct ray_info));
    assert(iray);

    struct geometric_var *g;
    g = (struct geometric_var*)malloc(sizeof(struct geometric_var));

    int *spm_id = (int*)malloc(sizeof(int)*NMESH_X_LOCAL*NMESH_XY_LOCAL);
    assert(spm_id);
    memset(spm_id, -1, NMESH_X_LOCAL*NMESH_XY_LOCAL);
    
    int pointer[NMESH_X_LOCAL];
    memset(pointer, 0, sizeof(int)*NMESH_X_LOCAL);
    
    int ipix = 0;
    for(int i=0; i<ig; i++) 
        ipix += hd_param->num_group_id[i];

    int num_group_id = hd_param->num_group_id[ig];
    
    for(int i=0; i<num_group_id; i++) {
        struct angle_info *a = &hd_param->angle[ipix + i];
        set_ray_start_position(iray, a, t);
        art_initialise(g, iray, a, t);

        if ( (g->ix_cur >= NMESH_X_LOCAL) ||
             (g->iy_cur >= NMESH_Y_LOCAL) ||
             (g->iz_cur >= NMESH_Z_LOCAL) ||
             (g->ix_cur < 0) ||
             (g->iy_cur < 0) ||
             (g->iz_cur < 0) )
            continue;
        //printf("[%d] ", hd_param->angle[ipix+i].base_id);
        while(1) {
            //printf("%f %f %f %d/%d \n", iray->x, iray->y, iray->z, i, num_group_id);
            int return_val = 0;
            art_geometric(g, iray, a->base_id, pointer, spm_id);
            //art_while_inner(iray, t, g, c, hd_param->rmesh);
            ray_cycle(a->base_id, iray, t, g, &return_val);
            if (return_val) break;
        } //while loop
    } // cone
    
    /* printf("base_id %d\n",hd_param->angle[ipix].base_id); */
    make_sandgrass(spm_id, pointer);

    /* for(int i=0; i<NMESH_X_LOCAL; i++) { */
    /*     printf("layer %2d [%3d] : ",i,pointer[i]); */
    /*     for(int j=0; j<pointer[i]-1; j++) { */
    /*         //printf("%3d ",spm_id[i*NMESH_XY_LOCAL+j]); */
    /*         printf("+"); */
    /*     } */
    /*     printf("\n"); */
    /* } */

    free(iray); free(g); free(spm_id);
}

void art_geometric(struct geometric_var *g, struct ray_info *iray, int base_id, int *pointer, int *spm_id)
{
    g->pos = g->ix_cur + NMESH_Z_LOCAL*g->iy_cur + NMESH_X_LOCAL*NMESH_Y_LOCAL*g->iz_cur;

    //printf("%d %d %d\n",g->ix_cur,g->iy_cur ,g->iz_cur);
    
    int layer, p;
    switch(base_id) {
    case 0: case 1:
        layer = g->iz_cur;
        p = layer * NMESH_XY_LOCAL + pointer[layer]++;
        spm_id[p] = g->ix_cur + NMESH_Z_LOCAL*g->iy_cur;
        break;
    case 2: case 3:
        layer = g->ix_cur;
        p = layer * NMESH_XY_LOCAL+ pointer[layer]++;
        spm_id[p] = g->iy_cur + NMESH_Z_LOCAL*g->iz_cur;
        break;
    case 4: case 5:
        layer = g->iy_cur;
        p = layer * NMESH_XY_LOCAL + pointer[layer]++;
        spm_id[p] = g->iz_cur + NMESH_Z_LOCAL*g->ix_cur;
        break;
    default:
        exit(1);
    }
    /* if(spm_id[p]==0)printf("cur %d %d %d layer %d\n",g->ix_cur,g->iy_cur,g->iz_cur,layer); */
//    if(pointer[layer]-1 >= RAY_CONE_NUM*2) pointer[layer] = 0;

    if (g->keep_zr <= g->keep_xr && g->keep_zr <= g->keep_yr) {
        g->rmin = g->keep_zr - g->current_r;
        g->current_r = g->keep_zr;
        g->keep_zr += g->step_zr;
        g->iz_cur += (g->zovr > 0.0e0f) ? 1 : -1;
    } else if (g->keep_yr <= g->keep_xr && g->keep_yr <= g->keep_zr) {
        g->rmin = g->keep_yr - g->current_r;
        g->current_r = g->keep_yr;
        g->keep_yr += g->step_yr;
        g->iy_cur += (g->yovr > 0.0e0f) ? 1 : -1;
    } else if(g->keep_xr <= g->keep_yr && g->keep_xr <= g->keep_zr) {
        g->rmin = g->keep_xr - g->current_r;
        g->current_r = g->keep_xr;
        g->keep_xr += g->step_xr;
        g->ix_cur += (g->xovr > 0.0e0f) ? 1 : -1;
    }
    iray->x = g->start_x + g->current_r * g->xovr;
    iray->y = g->start_y + g->current_r * g->yovr;
    iray->z = g->start_z + g->current_r * g->zovr;           
}

void ray_cycle(short base_id, struct ray_info *iray, struct run_param *t, struct geometric_var *g, int *return_val)
             
{    
    if ( (g->ix_cur >= NMESH_X_LOCAL) ||
         (g->iy_cur >= NMESH_Y_LOCAL) ||
         (g->iz_cur >= NMESH_Z_LOCAL) ||
         (g->ix_cur < 0) ||
         (g->iy_cur < 0) ||
         (g->iz_cur < 0)) {

        iray->I_inHI = 0.0e0f;

        switch(base_id){
        case(0): case(1): //xy
            if(g->ix_cur >= NMESH_X_LOCAL) {
                g->start_x -= NMESH_X_LOCAL*t->delta_x;
                g->ix_cur = 0;
                iray->x = t->xmin_local;
            }
            else if(g->ix_cur < 0) {
                g->start_x += NMESH_X_LOCAL*t->delta_x;
                g->ix_cur = NMESH_X_LOCAL-1;
                iray->x = t->xmax_local;
            }
            if(g->iy_cur >= NMESH_Y_LOCAL) {
                g->start_y -= NMESH_Y_LOCAL*t->delta_y;
                g->iy_cur = 0;
                iray->y = t->ymin_local;
            }
            else if(g->iy_cur < 0) {
                g->start_y += NMESH_Y_LOCAL*t->delta_y;
                g->iy_cur = NMESH_Y_LOCAL-1;
                iray->y = t->ymax_local;
            }
            break;
        case(2): case(3): //yz
            if(g->iy_cur >= NMESH_Y_LOCAL) {
                g->start_y -= NMESH_Y_LOCAL*t->delta_y;
                g->iy_cur = 0;
                iray->y = t->ymin_local;
            }
            else if(g->iy_cur < 0) {
                g->start_y += NMESH_Y_LOCAL*t->delta_y;
                g->iy_cur = NMESH_Y_LOCAL-1;
                iray->y = t->ymax_local;                
            }
            if(g->iz_cur >= NMESH_Z_LOCAL) {
                g->start_z -= NMESH_Z_LOCAL*t->delta_z;
                g->iz_cur = 0;
                iray->z = t->zmin_local;
            }
            else if(g->iz_cur < 0) {
                g->start_z += NMESH_Z_LOCAL*t->delta_z;
                g->iz_cur = NMESH_Z_LOCAL-1;
                iray->z = t->zmax_local;
            }
            break;  //break switch (2)(3)
        case(4): case(5): //zx
            if(g->iz_cur >= NMESH_Z_LOCAL) {
                g->start_z -= NMESH_Z_LOCAL*t->delta_z;
                g->iz_cur = 0;
                iray->z = t->zmin_local;
            }
            else if(g->iz_cur < 0) {
                g->start_z += NMESH_Z_LOCAL*t->delta_z;
                g->iz_cur = NMESH_Z_LOCAL-1;
                iray->z = t->zmax_local;
            }
            if(g->ix_cur >= NMESH_X_LOCAL) {
                g->start_x -= NMESH_X_LOCAL*t->delta_x;
                g->ix_cur = 0;
                iray->x = t->xmin_local;
            }	    
            else if(g->ix_cur < 0) {
                g->start_x += NMESH_X_LOCAL*t->delta_x;
                g->ix_cur = NMESH_X_LOCAL-1;
                iray->x = t->xmax_local;
            }      
            break;  //break switch (4)(5)
        } // end switch
        if ( (g->ix_cur >= NMESH_X_LOCAL) ||
             (g->iy_cur >= NMESH_Y_LOCAL) ||
             (g->iz_cur >= NMESH_Z_LOCAL) ||
             (g->ix_cur < 0) ||
             (g->iy_cur < 0) ||
             (g->iz_cur < 0)) *return_val = 1;
    }
}

void art_initialise(struct geometric_var *g, struct ray_info *iray,
                    struct angle_info *a, struct run_param *t)
{
    float lc_offset_x,lc_offset_y,lc_offset_z; // offset of local block offset
    float ms_offset_x,ms_offset_y,ms_offset_z; // offset of mesh offset
    float roffset_x,roffset_y,roffset_z;    
    g->xovr = a->xovr;
    g->yovr = a->yovr;
    g->zovr = a->zovr;
    
    g->start_x = iray->x;
    g->start_y = iray->y;
    g->start_z = iray->z;
    
    lc_offset_x = iray->x - t->xmin_local;
    lc_offset_y = iray->y - t->ymin_local;
    lc_offset_z = iray->z - t->zmin_local;
    //printf("iray %f %f %f\n", iray->x, iray->y, iray->z);
    //printf("lc_offset %f : %f : %f \n", lc_offset_x, lc_offset_y, lc_offset_z);
        
    g->ix_cur = lc_offset_x/t->delta_x;
    g->iy_cur = lc_offset_y/t->delta_y;
    g->iz_cur = lc_offset_z/t->delta_z;
    //printf("ir_cur %d : %d : %d \n", g->ix_cur , g->iy_cur, g->iz_cur);

    //start point is grid point.
    if( g->xovr < 0.0e0f && g->ix_cur==NMESH_X_LOCAL) --g->ix_cur;
    if( g->yovr < 0.0e0f && g->iy_cur==NMESH_Y_LOCAL) --g->iy_cur;
    if( g->zovr < 0.0e0f && g->iz_cur==NMESH_Z_LOCAL) --g->iz_cur;
    
    ms_offset_x = lc_offset_x - t->delta_x*(float)g->ix_cur;
    ms_offset_y = lc_offset_y - t->delta_y*(float)g->iy_cur;
    ms_offset_z = lc_offset_z - t->delta_z*(float)g->iz_cur;
    //printf("ms_offset %f : %f : %f \n", ms_offset_x, ms_offset_y, ms_offset_z);
    
    g->step_xr = fabsf(t->delta_x / g->xovr); // always+
    g->step_yr = fabsf(t->delta_y / g->yovr);
    g->step_zr = fabsf(t->delta_z / g->zovr);
    
    //printf("delta %f %f %f\n", delta_x, delta_y, delta_z);
    //printf("step_r %f  %f  %f \n", g->step_xr, g->step_yr, g->step_zr);

    // true : false
    if(g->xovr > 0.0e0f)
        roffset_x = ms_offset_x / g->xovr;
    else
        roffset_x = (ms_offset_x != 0.0f) ?  (ms_offset_x - t->delta_x) / g->xovr : 0.0f;
    if(g->yovr > 0.0e0f)
        roffset_y = ms_offset_y / g->yovr;
    else
        roffset_y = (ms_offset_y != 0.0f) ?  (ms_offset_y - t->delta_y) / g->yovr : 0.0f;
    if(g->zovr > 0.0e0f)
        roffset_z = ms_offset_z / g->zovr;
    else
        roffset_z = (ms_offset_z != 0.0f) ?  (ms_offset_z - t->delta_z) / g->zovr : 0.0f;
    //printf("roffset %f : %f : %f \n", roffset_x, roffset_y, roffset_z);
    
    g->keep_xr = -roffset_x + g->step_xr; // always +
    g->keep_yr = -roffset_y + g->step_yr;
    g->keep_zr = -roffset_z + g->step_zr;
    //printf("keep_r %f %f %f\n", keep_xr, keep_yr, keep_zr);
    g->current_r = 0;
    
    //printf("ovr %f %f %f\n",g->xovr,g->yovr,g->zovr);
}

void art_while_inner(struct ray_info *iray, struct run_param *t, struct geometric_var *g,
                     struct calculation_var *c, struct radiation_mesh *rmesh)
{
    c->tau               = rmesh[g->pos].absorptionHI * ( g->rmin * t->lunit );
    c->etau              = exp(-c->tau);
    c->etaum1            = -expm1(-c->tau);
    rmesh[g->pos].IHI   += iray->I_inHI*c->etaum1;
    rmesh[g->pos].tauHI += c->tau;
    iray->I_inHI         = iray->I_inHI*c->etau + rmesh[g->pos].source_funcHI*c->etaum1;
}
