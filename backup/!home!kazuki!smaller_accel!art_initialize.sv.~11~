//-----------------------------------------------------------------------------
// Title         : 
// Project       : smaller_accel
//-----------------------------------------------------------------------------
// File          : art_geometric.sv
// Author        : kazuki  <kazuki@kz-desk>
// Created       : 25.08.2020
// Last modified : 25.08.2020
//-----------------------------------------------------------------------------
// Description :
// 
//-----------------------------------------------------------------------------
// Copyright (c) 2020 by  This model is the confidential and
// proprietary property of  and the possession or use of this
// file requires a written license from .
//------------------------------------------------------------------------------
// Modification history :
// 25.08.2020 : created
//-----------------------------------------------------------------------------

`include "top_package.sv"
//`include "AXI3.sv"
`include "AXIS.sv"

module art_initialize
  import top_package::*;
    import parameters::*;
    import structures::*;
    (
     input clk_200,
     input aresetn_200
     );

    ray_info iray;
    angle_info a;
    geometric g;
    
    // ipix: 751, theta:2.000572, phi:5.105088, 
    // xovr:0.347882, yovr:-0.839861, zovr:-0.416667, base_id:5, corner_id:3
    assign iray.x = $shortrealtobits(1.5);
    assign iray.y = $shortrealtobits(1.6);
    assign iray.z = $shortrealtobits(1.7);
    assign g.xovr = $shortrealtobits(0.347882);
    assign g.yovr = $shortrealtobits(-0.839861);    
    assign g.zovr = $shortrealtobits(-0.416667);
    
    float lc_offset_xyz, ms_offset_xyz, 
      roffset_sub, roffset, step_r, xyz_cur, 
      cur_decr, xyz_cur_float, keep_r;
    int32 xyz_cur_int;
    float delta_xyz = 'h3E00_0000;
    float ms_offset_mul;
    
    AXIS sub(), div(), eq(), comp(), mul(), float_int(), int_float();
    
    assign g.start_x = iray.x;
    assign g.start_y = iray.y;
    assign g.start_z = iray.z;

    float iray_xyz;
    float p_y[1], p_z[2];
    float xyz_ovr, p_xyz_ovr[100];
    float p_lc_offset[60];
    float p_yovr[1], p_zovr[2];
    state_xyz xyz;
    // input : iray.x xovr

    art_initialize_state state, div_state;

    float xyz_min_local = 'h3F00_0000;
    reg p_aresetn;
    reg step_state = 0;
    
    // make data pipelined
    always_ff @(posedge clk_200) begin
        // iray.x iray.y iray.z
        if(~aresetn_200) begin
            xyz <= END_XYZ;
            sub.a_tdata <= 0;
            sub.b_tdata <= 0;
        end 
        else if(aresetn_200 & ~p_aresetn)begin
            xyz <= X;
        end
        p_aresetn <= aresetn_200;
        case(xyz)
            X: begin
                //xyz_min_local <= 0;
                iray_xyz  <= iray.x;
                p_y[0]    <= iray.y;
                p_z[0]    <= iray.z;
                xyz_ovr   <= g.xovr;
                p_yovr[0] <= g.yovr;
                p_zovr[0] <= g.zovr;
                xyz       <= Y;
            end
            Y: begin
                iray_xyz  <= p_y[0];
                p_z[1]    <= p_z[0];
                xyz_ovr   <= p_yovr[0];
                p_zovr[1] <= p_zovr[0];
                xyz       <= Z;
            end
            Z: begin
                iray_xyz  <= p_z[1];
                xyz_ovr   <= p_zovr[1];
                xyz       <= END_XYZ;
            end
            default: begin
                iray_xyz  <= 0;
                xyz_ovr   <= 0;
            end
        endcase // case (xyz)
        
        for(integer i=0; i < 100 ;i++) begin
            p_xyz_ovr[i] <= (i==0) ? xyz_ovr : p_xyz_ovr[i-1];
            p_lc_offset[i] <= (i==0) ? lc_offset_xyz : p_lc_offset[i-1];
        end
    end // always_ff @ (posedge clk_200)
    
    reg [15:0] count;

    logic comp_result;
    reg start_calc;
    logic isnot_grid;
    // RESET
    always_ff @ (posedge clk_200) begin
        if(~aresetn_200) begin
            step_state = 0;
            state <= RESET;
            start_calc <= 0;
        end
        else if (aresetn_200 & ~p_aresetn) begin
            start_calc <= 1;
        end
        if(start_calc) begin
            state <= LC_SUB;
            count <= 0;
            start_calc <= 0;
        end
    end // always_ff @ (posedge clk_200)

    // LC_OFFSET
    always_ff @ (posedge clk_200) begin
        case(state)
            LC_SUB: begin
                if(count >= 2) begin
                    state <= LC_SUB_WAIT;
                    count <= 0;
                end
                else 
                  count <= count + 1;
            end
            LC_SUB_WAIT: begin
                if(count >= SUB_LATENCY-3) begin
                    div_state <= CUR_DIV;
                    state <= CUR_DIV;
                    count <= 0;
                end
                else 
                  count <= count + 1;
            end
        endcase // case (state)
    end // always_ff @ (posedge clk_200)

    // CUR
    always_ff @ (posedge clk_200) begin
        case(state)
            CUR_DIV: begin
                if(count >= 2) begin
                    state <= CUR_DIV_WAIT;
                    count <= 0;
                end
                else
                    count <= count + 1;
            end
            CUR_DIV_WAIT: begin
                if(count >= DIV_LATENCY-3) begin
                    state <= CUR_INT;
                    count <= 0;
                end
                else
                  count <= count + 1;
            end
            CUR_INT: begin
                if(count >= 2) begin
                    state <= CUR_INT_WAIT;
                    count <= 0;
                end
                else
                  count <= count + 1;
            end
            CUR_INT_WAIT: begin
                if(count >= INT_LATENCY-3) begin
                    state <= CUR_DECR;
                    count <= 0;
                end
                else 
                  count <= count + 1;
            end
            CUR_DECR: begin
                if(count >= 2) begin
                    state <= CUR_FLOAT;
                    count <= 0;
                end
                else 
                  count <= count + 1;
            end
            CUR_FLOAT: begin
                if(count >= 2) begin
                    state <= CUR_FLOAT_WAIT;
                    count <= 0;
                end
                else
                  count <= count + 1;
            end
            CUR_FLOAT_WAIT: begin
                if(count >= FLOAT_LATENCY-3) begin
                    state <= MS_MUL;
                    count <= 0;
                end
                else 
                  count <= count + 1;
            end
        endcase // case (state)
    end // always_ff @ (posedge clk_200)

    // name result
    always_comb begin
        case(state)
            CUR_DIV: begin
                lc_offset_xyz = sub.r_tdata;
            end
            CUR_INT: begin 
                xyz_cur = div.r_tdata;
            end
            CUR_DECR: begin
                xyz_cur_int = float_int.r_tdata;
            end
            MS_MUL: begin
                xyz_cur_float = int_float.r_tdata;
            end
            MS_SUB: begin
                ms_offset_mul = mul.r_tdata;
            end
            ROFFSET_SUB: begin
                ms_offset_xyz = sub.r_tdata;
            end
            ROFFSET_DIV: begin
                roffset_sub = sub.r_tdata;
            end
            KEEP_R_SUB: begin
                roffset = div.r_tdata;
            end
            END_0: begin
                keep_r = sub.r_tdata;
            end
            default: begin
                xyz_cur_int = 'x;
                xyz_cur = 'x;
                lc_offset_xyz = 'x;
            end
        endcase // case (state)
    end // always_comb

    reg [15:0] step_count = 0;
    // MS_OFFSET
    always_ff @ (posedge clk_200) begin
        case(state) 
            MS_MUL: begin
                if(count >= 2) begin
                    state <= MS_MUL_WAIT;
                    count <= 0;
                end
                else 
                  count <= count + 1;
            end
            MS_MUL_WAIT: begin
                if(count > MUL_LATENCY-3) begin
                    state <= MS_SUB;
                    count <= 0;
                end
                else
                  count <= count + 1;
            end            
            MS_SUB: begin
                if(count >= 2) begin
                    state <= MS_SUB_WAIT;
                    count <= 0;
                end
                else 
                  count <= count + 1;
            end
            MS_SUB_WAIT: begin
                if(count >= SUB_LATENCY-3) begin
                    state <= ROFFSET_SUB;
                    count <= 0;
                end
                else 
                  count <= count + 1;
            end            
        endcase // case (state)
    end // always_ff @ (posedge clk_200)

    // STEP_R
    always_ff @ (posedge clk_200) begin
        case(state)
            STEP_R_DIV: begin
                if(count >= 2) begin
                    state <= STEP_R_DIV_WAIT;
                    count <= 0;
                end
                else 
                  count <= count + 1;
            end
            STEP_R_DIV_WAIT: begin
                if(count >= DIV_LATENCY) begin
                    state <= ROFFSET_SUB;
                    count <= 0;
                end
                else 
                  count <= count + 1;
            end            
        endcase // case (state)
    end // always_ff @ (posedge clk_200)

    float p_step_r[2];
    // R_OFFSET
    always_ff @ (posedge clk_200) begin
        if(step_state) begin
            if(step_count < 3) begin
                div.a_tdata <= delta_xyz;
                div.b_tdata <= p_xyz_ovr[94];
                div.a_tvalid <= 1;
                div.b_tvalid <= 1;
            end
            if(step_count > DIV_LATENCY) begin
                p_step_r[0] <= div.r_tdata;
            end 
            if(step_count > DIV_LATENCY + 5) begin
                p_step_r[0] <= 'x;
                step_count <= 0;
                step_state <= 0;
            end
            p_step_r[1] <= p_step_r[0];
            step_r <= p_step_r[1];
            step_count <= step_count + 1;
        end // if (div_state == STEP_R_DIV)
    end // always_ff @ (posedge clk_200)

    always_ff @ (posedge clk_200) begin
        case(state)
            ROFFSET_SUB: begin
                if(count >= 2) begin
                    state <= ROFFSET_SUB_WAIT;
                    count <= 0;
                end
                else
                  count <= count + 1;
            end
            ROFFSET_SUB_WAIT: begin
                if(count >= SUB_LATENCY-3) begin
                    state <= ROFFSET_DIV;
                    div_state <= ROFFSET_DIV;
                    count <= 0;
                end
                else begin
                    if(count >= SUB_LATENCY-6) begin
                        step_state <= 1;
                        div_state <= STEP_R_DIV;
                    end
                    count <= count + 1;
                end
            end
            ROFFSET_DIV: begin
                if(count >= 2) begin
                    state <= ROFFSET_DIV_WAIT;
                    count <= 0;
                end
                else
                  count <= count + 1;
            end
            ROFFSET_DIV_WAIT: begin
                if(count >= DIV_LATENCY-3) begin
                    state <= KEEP_R_SUB;
                    count <= 0;
                end
                else
                  count <= count + 1;
            end
        endcase // case (state)
    end // always_ff @ (posedge clk_200)

    // KEEP_R
    always_ff @ (posedge clk_200) begin
        case(state)
            KEEP_R_SUB: begin
                if(count >= 2) begin
                    state <= KEEP_R_SUB_WAIT;
                    count <= 0;
                end
                else
                  count <= count + 1;
            end
            KEEP_R_SUB_WAIT: begin
                if(count >= SUB_LATENCY-3) begin
                    state <= END_0;
                    count <= 0;
                end
                else
                  count <= count + 1;
            end
            END_0: begin
                if(count >= 2) begin
                    state <= RESET;
                    count <= 0;
                end
                else
                  count <= count + 1;
        end
        endcase
    end // always_ff @ (posedge clk_200)

    always_ff @(posedge clk_200) begin
        case(state)
            CUR_INT: begin
                float_int.a_tdata <= xyz_cur;
                float_int.a_tvalid <= 1;
            end
            CUR_FLOAT: begin
                int_float.a_tdata <= cur_decr;
                int_float.a_tvalid <= 1;
            end
            default: begin
                float_int.a_tdata <= 'x;
                float_int.a_tvalid <= 0;
                int_float.a_tdata <= 'x;
                int_float.a_tvalid <= 0;
            end
        endcase // case (div_state)
    end // always_ff @ (posedge clk_200)

    always_ff @(posedge clk_200) begin
        case(state)
            // lc_offset_x = iray.x - t.xmin_local;
            LC_SUB: begin
                sub.a_tdata <= iray_xyz;
                sub.b_tdata <= xyz_min_local;
                sub.a_tvalid <= 1;
                sub.b_tvalid <= 1;
            end
            MS_SUB: begin
                sub.a_tdata <= p_lc_offset[58];
                sub.b_tdata <= ms_offset_mul;
                sub.a_tvalid <= 1;
                sub.b_tvalid <= 1;
            end
            ROFFSET_SUB: begin
                if(ms_offset_xyz == 0) begin
                    sub.a_tdata <= 0;
                    sub.b_tdata <= 0;
                end
                else begin
                    sub.a_tdata <= ms_offset_xyz;
                    sub.b_tdata <= p_xyz_ovr[60][31] ? delta_xyz : 0;
                end
                // ovr < 0 : ovr > 0
                sub.a_tvalid <= 1;
                sub.b_tvalid <= 1;
            end
            // g.keep_xr = -roffset_x + g.step_xr;
            KEEP_R_SUB: begin
                sub.a_tdata <= step_r;
                sub.b_tdata <= roffset;
                sub.a_tvalid <= 1;
                sub.b_tvalid <= 1;
            end
            // current = 0
            default: begin
                sub.a_tdata <= 0;
                sub.b_tdata <= 0;
                sub.a_tvalid <= 0;
                sub.b_tvalid <= 0;
            end
        endcase // case (state)
    end // always_ff @ (posedge clk_200)
    
    always_ff @(posedge clk_200) begin
        case(div_state)
            // ** cur is int
            // g.ix_cur = lc_offset_x / t.delta_x;
            CUR_DIV: begin
                div.a_tdata <= lc_offset_xyz;
                div.b_tdata <= delta_xyz;
                div.a_tvalid <= 1;
                div.b_tvalid <= 1;
            end
            // g.step_xr = fabsf(t.delta_x / g.xovr); // always+
            STEP_R_DIV: begin
                div.a_tdata <= delta_xyz;
                div.b_tdata <= {1'b0, p_xyz_ovr[94][30:0]}; // ignore sign
                div.a_tvalid <= 1;
                div.b_tvalid <= 1;
            end
            ROFFSET_DIV: begin
                div.a_tdata <= roffset_sub;
                div.b_tdata <= p_xyz_ovr[97];
                div.a_tvalid <= 1;
                div.b_tvalid <= 1;
            end
            default: begin
                div.a_tdata <= 0;
                div.b_tdata <= 0;
                div.a_tvalid <= 0;
                div.b_tvalid <= 0;
            end
        endcase // case (div_state)
    end // always_
            
    always_ff @(posedge clk_200) begin
        case(state)
            MS_MUL:begin
                mul.a_tdata <= xyz_cur_float;
                mul.b_tdata <= delta_xyz;
                mul.a_tvalid <= 1;
                mul.b_tvalid <= 1;
            end
            default: begin
                mul.a_tdata <= 0;
                mul.b_tdata <= 0;
                mul.a_tvalid <= 0;
                mul.b_tvalid <= 0;
            end
        endcase // case (state)
    end // always_ff @ (posedge clk_200)

    initial begin
        sub.a_tvalid = 0;
        sub.b_tvalid = 0;
        div.a_tvalid = 0;
        div.b_tvalid = 0;
        comp.a_tvalid = 0;
        comp.b_tvalid = 0;
        eq.a_tvalid = 0;
        eq.b_tvalid = 0;
        float_int.a_tvalid = 0;
        mul.a_tvalid = 0;
        mul.b_tvalid = 0;
        int_float.a_tvalid = 0;
    end
    
    assign sub.aclk = clk_200;
    assign sub.aresetn = aresetn_200;
    assign div.aclk = clk_200;
    assign mul.aclk = clk_200;
    assign eq.aclk = clk_200;
    assign float_int.aclk = clk_200;
    assign int_float.aclk = clk_200;

    sub sub_0(.axis(sub));
    float_int_top float_int_0(.axis(float_int));
    int_float_top int_float_0(.axis(int_float));
    div div_0(.axis(div));
    cur_decr cur_decr_0
      (
       .clk(clk_200),.resetn(aresetn_200),
       .NMESH_XYZ_LOCAL(NMESH_X_LOCAL),
       .xyz_ovr_31(p_xyz_ovr[50][31]),.xyz_cur(xyz_cur_int),
       .cur_rlt(cur_decr)
       );
    comp comp_0(.clk(clk_200),.in(ms_offset_xyz),.out(ms_offset_zero));
    mul mul_0(.axis(mul));
    
endmodule // art_initialize


