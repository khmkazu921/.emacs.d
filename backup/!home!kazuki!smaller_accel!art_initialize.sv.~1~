//-----------------------------------------------------------------------------
// Title         : 
// Project       : smaller_accel
//-----------------------------------------------------------------------------
// File          : art_geometric.sv
// Author        : kazuki  <kazuki@kz-desk>
// Created       : 25.08.2020
// Last modified : 25.08.2020
//-----------------------------------------------------------------------------
// Description :
// 
//-----------------------------------------------------------------------------
// Copyright (c) 2020 by  This model is the confidential and
// proprietary property of  and the possession or use of this
// file requires a written license from .
//------------------------------------------------------------------------------
// Modification history :
// 25.08.2020 : created
//-----------------------------------------------------------------------------

`include "top_package.sv"
//`include "AXI3.sv"
`include "AXIS.sv"

module art_initialize
  import top_package::*;
    import parameters::*;
    import structures::*;
    (
     input clk_200,
     input aresetn_200
     );

    ray_info iray;
    angle_info a;
    geometric g;
    
    assign iray.x = 1;
    assign iray.y = 1;
    assign iray.z = 1;
    assign g.xovr = 'b100_0110;
    assign g.yovr = 'b001_1000;    
    assign g.zovr = 'b011_0110;
    
    float lc_offset_xyz, ms_offset_xyz, 
      roffset_xyz, step_xyzr, delta_xyz;
    int16 xyz_cur;
    
    AXIS sub(), div(), comp(), mul();
    
    assign g.start_x = iray.x;
    assign g.start_y = iray.y;
    assign g.start_z = iray.z;

    float iray_xyz;
    float p_y[1], p_z[2];
    double xyz_ovr;
    double p_yovr[1], p_zovr[2];
    state_xyz xyz;
    // input : iray.x xovr

    art_initialize_state state;

    float xyz_min_local;
    reg p_aresetn;
    // make data pipelined
    always_ff @(posedge clk_200) begin
        // iray.x iray.y iray.z
        p_aresetn <= aresetn_200;
        if(aresetn_200) begin
            xyz <= END;
        end 
        else if(aresetn_200 & ~p_aresetn)begin
            xyz <= X;
        end
        case(xyz)
            X: begin
                xyz_min_local <= 0;
                iray_xyz  <= iray.x;
                p_y[0]    <= iray.y;
                p_z[0]    <= iray.z;
                xyz_ovr   <= g.xovr;
                p_yovr[0] <= g.yovr;
                p_zovr[0] <= g.zovr;
                xyz       <= Y;
            end
            Y: begin
                iray_xyz  <= p_y[0];
                p_z[1]    <= p_z[0];
                xyz_ovr   <= p_yovr[0];
                p_zovr[1] <= p_zovr[0];
                xyz       <= Z;
            end
            Z: begin
                iray_xyz  <= p_z[1];
                xyz_ovr   <= p_zovr[1];
                xyz       <= END;
            end
            default: begin
                iray_xyz  <= 0;
                xyz_ovr   <= 0;
            end
        endcase
    end // always_ff @ (posedge clk_200)
    
    reg [15:0] count;

    float mul_result, sub_result, div_result;
    logic comp_result;
    float lc_offset_rlt;
    reg start_calc;
    
    // RESET
    always_ff @ (posedge clk_200) begin
        if(~aresetn_200) begin
            state <= RESET;
            start_calc <= 0;
        end
        else if (aresetn_200 & ~p_aresetn) begin
            start_calc <= 1;
        end
        
        if(start_calc) begin
            state <= LC_OFFSET_SUB;
            count <= 0;
            start_calc <= 0;
        end
        sub_result <= sub.r_tdata;
        mul_result <= mul.r_tdata;
        comp_result <= comp.r_tdata;
        div_result <= div.r_tdata;
    end

    // LC_OFFSET
    always_ff @ (posedge clk_200) begin
        case(state)
            LC_OFFSET_SUB: begin
                if(count > 3) begin
                    state <= LC_OFFSET_SUB_WAIT;
                    count <= 0;
                end
                count <= count + 1;
            end
            LC_OFFSET_SUB_WAIT: begin
                if(count > SUB_LATENCY-3) begin
                    state <= CUR_DIV;
                    count <= 0;
                end
                count <= count + 1;
            end
        endcase // case (state)
    end // always_ff @ (posedge clk_200)

    // CUR
    always_ff @ (posedge clk_200) begin
        case(state)
            CUR_DIV: begin
                if(count > 3) begin
                    state <= CUR_DIV_WAIT;
                    count <= 0;
                    lc_offset_rlt <= sub_result;
                end
                count <= count + 1;
            end
            CUR_DIV_WAIT: begin
                if(count > DIV_LATENCY-3) begin
                    state <= CUR_COMP;
                    count <= 0;
                end
                count <= count + 1;
            end
            CUR_COMP: begin
                if(count > 3) begin
                    state <= CUR_COMP_WAIT;
                    count <= 0;
                end
                count <= count + 1;
            end
            CUR_COMP_WAIT: begin
                if(count > COMP_LATENCY-3) begin
                    state <= CUR_SUB;
                    count <= 0;
                end
                count <= count + 1;
            end
            CUR_SUB: begin
                if(count > 3) begin
                    state <= CUR_SUB_WAIT;
                    count <= 0;
                end
                count <= count + 1;
            end
            CUR_SUB_WAIT: begin
                if(count > SUB_LATENCY-3) begin
                    state <= MS_OFFSET_MUL;
                    count <= 0;
                end
                count <= count + 1;
            end
        endcase // case (state)
    end // always_ff @ (posedge clk_200)

    // MS_OFFSET
    always_ff @ (posedge clk_200) begin
        case(state) 
            MS_OFFSET_MUL: begin
                if(count > 3) begin
                    state <= MS_OFFSET_MUL_WAIT;
                    count <= 0;
                end
                count <= count + 1;
            end
            MS_OFFSET_MUL_WAIT: begin
                if(count > MUL_LATENCY-3) begin
                    state <= MS_OFFSET_MUL;
                    count <= 0;
                end
                count <= count + 1;
            end            
            MS_OFFSET_SUB: begin
                if(count > 3) begin
                    state <= MS_OFFSET_SUB_WAIT;
                    count <= 0;
                end
                count <= count + 1;
            end
            MS_OFFSET_SUB_WAIT: begin
                if(count > SUB_LATENCY-3) begin
                    state <= STEP_R_DIV;
                    count <= 0;
                end
                count <= count + 1;
            end            
        endcase // case (state)
    end // always_ff @ (posedge clk_200)

    // STEP_R
    always_ff @ (posedge clk_200) begin
        case(state)
            STEP_R_DIV: begin
                if(count > 3) begin
                    state <= STEP_R_DIV_WAIT;
                    count <= 0;
                end
                count <= count + 1;
            end
            STEP_R_DIV_WAIT: begin
                if(count > DIV_LATENCY-3) begin
                    state <= ROFFSET_SUB;
                    count <= 0;
                end
                count <= count + 1;
            end            
        endcase // case (state)
    end // always_ff @ (posedge clk_200)

    // R_OFFSET
    always_ff @ (posedge clk_200) begin
        case(state)
            ROFFSET_SUB: begin
                if(count > 3) begin
                    state <= ROFFSET_SUB_WAIT;
                    count <= 0;
                end
                count <= count + 1;
            end
            ROFFSET_SUB_WAIT: begin
                if(count > SUB_LATENCY-3) begin
                    state <= ROFFSET_DIV;
                    count <= 0;
                end
                count <= count + 1;
            end        
            ROFFSET_DIV: begin
                if(count > 3) begin
                    state <= ROFFSET_DIV_WAIT;
                    count <= 0;
                end
                count <= count + 1;
            end
            ROFFSET_DIV_WAIT: begin
                if(count > DIV_LATENCY-3) begin
                    state <= KEEP_R_SUB;
                    count <= 0;
                end
                count <= count + 1;
            end
        endcase // case (state)
    end // always_ff @ (posedge clk_200)

    // KEEP_R
    always_ff @ (posedge clk_200) begin
        case(state)
            KEEP_R_SUB: begin
                if(count > 3) begin
                    state <= KEEP_R_SUB_WAIT;
                    count <= 0;
                end
                count <= count + 1;
            end
            KEEP_R_SUB_WAIT: begin
                if(count > SUB_LATENCY-3) begin
                    // state <= KEEP_R_DIV;
                    count <= 0;
                end
                count <= count + 1;
            end
        endcase
    end
    
    float ms_offset_mul;
    always_comb begin
        case(state)
            // lc_offset_x = iray.x - t.xmin_local;
            LC_OFFSET_SUB: begin
                sub.a_tdata = iray_xyz;
                sub.b_tdata = xyz_min_local;
                sub.a_tvalid = 1;
                sub.b_tvalid = 1;
            end
            CUR_SUB: begin
                sub.a_tdata = xyz_cur;
                sub.b_tdata = 32'h3F800000; // 1.0
                sub.a_tvalid = 1;
                sub.b_tvalid = 1;
            end
            MS_OFFSET_SUB: begin
                sub.a_tdata = lc_offset_xyz;
                sub.b_tdata = ms_offset_mul;
                sub.a_tvalid = 1;
                sub.b_tvalid = 1;
            end
            // if(ms_offset_x != 0.0) {
            //   if(g.xovr > 0.0e0f)
            //     roffset_x = (ms_offset_x - 0.0      ) / g.xovr;
            //   else
            //     roffset_x = (ms_offset_x - t.delta_x) / g.xovr;       
            // } else { roffset_x = 0.0; }
            ROFFSET_SUB: begin
                sub.a_tdata = ms_offset_xyz;
                sub.b_tdata = xyz_ovr[31] ? 0 : delta_xyz; // ovr < 0 : ovr > 0    
                sub.a_tvalid = 1;
                sub.b_tvalid = 1;
            end
            // g.keep_xr = -roffset_x + g.step_xr; // always +
            KEEP_R_SUB: begin
                sub.a_tdata = step_xyzr;
                sub.b_tdata = roffset_xyz;
                sub.a_tvalid = 1;
                sub.b_tvalid = 1;
            end
            // current = 0
            default: begin
                sub.a_tdata = 0;
                sub.b_tdata = 0;
                sub.a_tvalid = 0;
                sub.b_tvalid = 0;
            end
        endcase // case (state)
    end // always_comb
    
    always_comb begin
        case(state)
            // ** cur is float
            // g.ix_cur = lc_offset_x / t.delta_x;
            CUR_DIV: begin
                div.a_tdata = lc_offset_xyz;
                div.b_tdata = delta_xyz;
                div.a_tvalid = 1;
                div.b_tvalid = 1;
            end
            // g.step_xr = fabsf(t.delta_x / g.xovr); // always+
            STEP_R_DIV: begin
                div.a_tdata = delta_xyz;
                div.b_tdata = {1'b0, xyz_ovr[30:0]}; // ignore sign
                div.a_tvalid = 1;
                div.b_tvalid = 1;
            end
            ROFFSET_DIV: begin
                div.a_tdata = roffset_xyz;
                div.b_tdata = xyz_ovr;
                div.a_tvalid = 1;
                div.b_tvalid = 1;
            end
            default: begin
                div.a_tdata = 0;
                div.b_tdata = 0;
                div.a_tvalid = 0;
                div.b_tvalid = 0;
            end
        endcase // case (div_state)
    end // always_comb
    
    // if( g.xovr < 0.0e0f && g.ix_cur==NMESH_X_LOCAL) --g.ix_cur;
    assign comp.a_tdata = xyz_ovr;
    assign comp.b_tdata = 0; // 0.0e0f
    
    // ms_offset_x = lc_offset_x - t->delta_x*(float)g->ix_cur;
    assign mul.a_tdata = delta_xyz;
    assign mul.b_tdata = xyz_cur;

    sub sub_0(.axis(sub));
    div div_0(.axis(div));
    comp comp_0(.clk(clk_200),.in(ms_offset_xyz),.out(ms_offset_zero));
    mul mul_0(.axis(mul));
    
endmodule // art_initialize


